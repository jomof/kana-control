{"version":3,"file":"kana-control-logic.js","sourceRoot":"","sources":["src/kana-control-logic.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport { splitKotogram, extractTokenFeatures } from 'kotogram';\nimport * as wanakana from 'wanakana';\n\n/**\n * A Token represents a parsed Japanese morpheme with optional marking state.\n */\nexport interface Token {\n  marked: boolean | undefined;\n  surface_form: string;\n  reading?: string;\n  pos?: string;\n}\n\n/**\n * Grammar analysis for a Japanese answer sentence.\n * Contains linguistic information about formality, gender, register, etc.\n */\nexport interface GrammarAnalysis {\n  /** Linguistic encoding of the sentence in kotogram format */\n  kotogram: string;\n  /** Formality level of the sentence */\n  formality: 'formal' | 'neutral' | 'casual';\n  /** Raw formality score, approximately -1.0 to 1.0 */\n  formality_score: number;\n  /** Whether formality is context-dependent */\n  formality_is_pragmatic: boolean;\n  /** Gender tendency of the sentence */\n  gender: 'masculine' | 'feminine' | 'neutral';\n  /** Raw gender score, approximately -1.0 to 1.0 */\n  gender_score: number;\n  /** Whether gender is context-dependent */\n  gender_is_pragmatic: boolean;\n  /** Register categories, e.g., [\"neutral\"], [\"danseigo\"], [\"kansaiben\"] */\n  registers: string[];\n  /** Score for each possible register */\n  register_scores: Record<string, number>;\n  /** Whether the sentence is grammatically correct */\n  is_grammatic: boolean;\n  /** Grammaticality confidence score, typically 0.0 to 1.0 */\n  grammaticality_score: number;\n}\n\n/**\n * A Question contains the English prompt with furigana annotations and\n * multiple acceptable Japanese answers.\n */\nexport interface Question {\n  english: string;\n  japanese: string[];\n  parsed: Token[][];\n  /** Map from answer text to its grammar analysis */\n  answerGrammar: Record<string, GrammarAnalysis>;\n}\n\n/**\n * ParsedEnglishPart represents a word in the English prompt, optionally\n * with furigana (reading) attached.\n */\nexport interface ParsedEnglishPart {\n  englishWord: string;\n  furigana: string;\n}\n\nexport type ParsedEnglish = ParsedEnglishPart[];\n\n/**\n * Recursive helper to find matching tokens.\n * @returns an array of token‐indices if `str` can be covered by a subsequence\n *          of `tokens[i].reading`, or `null` otherwise.\n */\nexport function findMatch(\n  tokens: Token[],\n  str: string,\n  startIdx: number,\n  pos: number\n): number[] | null {\n  if (pos === str.length) return [];\n  for (let i = startIdx; i < tokens.length; i++) {\n    const r = tokens[i].reading!;\n    if (str.startsWith(r, pos)) {\n      const rest = findMatch(tokens, str, i + 1, pos + r.length);\n      if (rest) return [i, ...rest];\n    }\n  }\n  return null;\n}\n\n/** Flat‐array overload */\nexport function markTokens(\n  tokens: Token[],\n  str: string\n): { matched: number[] | null };\n\n/** Nested‐array overload */\nexport function markTokens(\n  tokens: Token[][],\n  str: string\n): { matched: number[] | null }[];\n\n/**\n * If given a flat Token[], tries to match & flip exactly as before.\n * If given Token[][], first picks only those sub‐arrays with the\n * **highest current count** of `marked===true`, and runs the flat logic\n * on them; all others return `{ matched: null }`.\n */\nexport function markTokens(\n  tokens: Token[] | Token[][],\n  str: string\n): { matched: number[] | null } | { matched: number[] | null }[] {\n  // ——— Nested case ———\n  if (tokens.length > 0 && Array.isArray(tokens[0])) {\n    const groups = tokens as Token[][];\n    const candidateGroups = getGroupsWithMaxMarkedTokens(groups);\n\n    return groups.map((g) => {\n      if (candidateGroups.includes(g)) {\n        return markTokens(g, str) as { matched: number[] | null };\n      } else {\n        return { matched: null };\n      }\n    });\n  }\n\n  // ——— Flat case ———\n  const flat = tokens as Token[];\n  const matchIndices = findMatch(flat, str, 0, 0);\n  if (!matchIndices) {\n    return { matched: null };\n  }\n\n  const newlyMarked: number[] = [];\n  for (const idx of matchIndices) {\n    if (!flat[idx].marked) {\n      flat[idx].marked = true;\n      newlyMarked.push(idx);\n    }\n  }\n  return { matched: newlyMarked };\n}\n\n/**\n * Filters an array of token groups, returning only those with the maximum\n * number of marked tokens.\n */\nexport function getGroupsWithMaxMarkedTokens(groups: Token[][]): Token[][] {\n  if (groups.length === 0) {\n    return [];\n  }\n\n  const markedCounts = groups.map((g) =>\n    g.reduce((n, t) => n + (t.marked ? 1 : 0), 0)\n  );\n  const maxMarkedCount = Math.max(...markedCounts);\n\n  return groups.filter((_, i) => markedCounts[i] === maxMarkedCount);\n}\n\n/**\n * Returns true if any token was newly marked.\n */\nexport function anyMarked(result: { matched: number[] | null }[]): boolean {\n  return result.some((r) => r.matched !== null && r.matched.length > 0);\n}\n\n/**\n * Selects the \"best\" token sequence from an array of candidate groups.\n * Criteria:\n *  1. Highest number of tokens with `marked === true`\n *  2. (Tiebreaker) Lowest number of tokens with `marked === false`\n */\nexport function selectBestGroup(groups: Token[][]): Token[] {\n  if (groups.length === 0) throw new Error('No groups provided');\n\n  const groupsWithMaxMarked = getGroupsWithMaxMarkedTokens(groups);\n\n  if (groupsWithMaxMarked.length === 1) {\n    return groupsWithMaxMarked[0];\n  }\n\n  let bestGroup = groupsWithMaxMarked[0];\n  let minTotalTokens = bestGroup.length;\n\n  for (let i = 1; i < groupsWithMaxMarked.length; i++) {\n    const currentGroup = groupsWithMaxMarked[i];\n    if (currentGroup.length < minTotalTokens) {\n      bestGroup = currentGroup;\n      minTotalTokens = currentGroup.length;\n    }\n  }\n\n  return bestGroup;\n}\n\n/**\n * Returns true if every non-punctuation token in the array is marked.\n * Checks for common Japanese punctuation POS tags.\n */\nexport function isCompleted(tokens: Token[]): boolean {\n  const punctuationPos = ['記号', 'aux-symbol', 'aux-symbol:period', 'aux-symbol:comma'];\n  return tokens.every((t) => punctuationPos.some(p => t.pos?.startsWith(p)) || t.marked);\n}\n\n/**\n * Parses a kotogram string into an array of Tokens.\n * Uses splitKotogram and extractTokenFeatures from kotogram library.\n */\nfunction parseKotogramToTokens(kotogram: string): Token[] {\n  const tokenStrings = splitKotogram(kotogram);\n  return tokenStrings.map((tokenStr) => {\n    const features = extractTokenFeatures(tokenStr);\n    // Convert katakana reading to hiragana for matching (user types hiragana)\n    // If no reading is present, convert surface to hiragana (handles katakana words like テスト)\n    const hiraganaReading = features.reading\n      ? wanakana.toHiragana(features.reading)\n      : wanakana.toHiragana(features.surface);\n    return {\n      surface_form: features.surface,\n      reading: hiraganaReading,\n      pos: features.pos,\n      marked: false,\n    };\n  });\n}\n\n/**\n * Creates a Question object from an English prompt and Japanese answer(s).\n * English can include furigana annotations in brackets: \"word[ふりがな]\"\n *\n * @param english - English text with optional furigana annotations\n * @param japanese - Array of acceptable Japanese answers\n * @param answerGrammar - Map from answer text to grammar analysis.\n *                        Each answer MUST have a corresponding entry with kotogram data.\n * @returns A Question object with parsed Japanese tokens\n *\n * @example\n * ```ts\n * const q = await makeQuestion('I live[すむ] in Seattle[シアトル].', \n *   ['私はシアトルに住んでいます。'],\n *   {\n *     '私はシアトルに住んでいます。': {\n *       kotogram: '⌈ˢ私ᵖpronʳワタシ⌉⌈ˢはᵖparticleʳハ⌉...',\n *       formality: 'formal',\n *       formality_score: 0.5,\n *       gender: 'neutral',\n *       gender_score: 0,\n *       formality_is_pragmatic: false,\n *       gender_is_pragmatic: false,\n *       registers: ['neutral'],\n *       register_scores: {},\n *       is_grammatic: true,\n *       grammaticality_score: 1.0,\n *     }\n *   }\n * );\n * ```\n */\nexport async function makeQuestion(\n  english: string,\n  japanese: string[],\n  answerGrammar: Record<string, GrammarAnalysis>\n): Promise<Question> {\n  const parsed: Token[][] = japanese.map((answer) => {\n    const grammar = answerGrammar[answer];\n    if (!grammar?.kotogram) {\n      throw new Error(`Missing kotogram data for answer: \"${answer}\"`);\n    }\n    return parseKotogramToTokens(grammar.kotogram);\n  });\n\n  return {\n    english,\n    japanese,\n    parsed,\n    answerGrammar,\n  };\n}\n\nexport function parseEnglishString(eng: string): ParsedEnglish {\n  const regex = /([a-zA-Z0-9_']+)\\s*(?:\\[([^\\]]+)\\])?/g;\n  const parts: ParsedEnglish = [];\n  let match;\n  while ((match = regex.exec(eng)) !== null) {\n    parts.push({\n      englishWord: match[1],\n      furigana: match[2] || '',\n    });\n  }\n  return parts;\n}\n"]}