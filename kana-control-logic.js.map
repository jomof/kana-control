{"version":3,"file":"kana-control-logic.js","sourceRoot":"","sources":["src/kana-control-logic.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAE,QAAQ,EAAE,MAAM,eAAe,CAAC;AACzC,OAAO,EAAE,kBAAkB,EAAE,MAAM,cAAc,CAAC;AAiClD;;;;GAIG;AACH,MAAM,UAAU,SAAS,CACvB,MAAe,EACf,GAAW,EACX,QAAgB,EAChB,GAAW;IAEX,IAAI,GAAG,KAAK,GAAG,CAAC,MAAM;QAAE,OAAO,EAAE,CAAC;IAClC,KAAK,IAAI,CAAC,GAAG,QAAQ,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QAC9C,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,OAAQ,CAAC;QAC7B,IAAI,GAAG,CAAC,UAAU,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,CAAC;YAC3B,MAAM,IAAI,GAAG,SAAS,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC;YAC3D,IAAI,IAAI;gBAAE,OAAO,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC,CAAC;QAChC,CAAC;IACH,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAcD;;;;;GAKG;AACH,MAAM,UAAU,UAAU,CACxB,MAA2B,EAC3B,GAAW;IAEX,sBAAsB;IACtB,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QAClD,MAAM,MAAM,GAAG,MAAmB,CAAC;QACnC,MAAM,eAAe,GAAG,4BAA4B,CAAC,MAAM,CAAC,CAAC;QAE7D,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE;YACtB,IAAI,eAAe,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;gBAChC,OAAO,UAAU,CAAC,CAAC,EAAE,GAAG,CAAiC,CAAC;YAC5D,CAAC;iBAAM,CAAC;gBACN,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;YAC3B,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED,oBAAoB;IACpB,MAAM,IAAI,GAAG,MAAiB,CAAC;IAC/B,MAAM,YAAY,GAAG,SAAS,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAChD,IAAI,CAAC,YAAY,EAAE,CAAC;QAClB,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;IAC3B,CAAC;IAED,MAAM,WAAW,GAAa,EAAE,CAAC;IACjC,KAAK,MAAM,GAAG,IAAI,YAAY,EAAE,CAAC;QAC/B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC;YACtB,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC;YACxB,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACxB,CAAC;IACH,CAAC;IACD,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,CAAC;AAClC,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,4BAA4B,CAAC,MAAiB;IAC5D,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACxB,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,MAAM,YAAY,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CACpC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAC9C,CAAC;IACF,MAAM,cAAc,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC,CAAC;IAEjD,OAAO,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,YAAY,CAAC,CAAC,CAAC,KAAK,cAAc,CAAC,CAAC;AACrE,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,SAAS,CAAC,MAAsC;IAC9D,OAAO,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,KAAK,IAAI,IAAI,CAAC,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AACxE,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,eAAe,CAAC,MAAiB;IAC/C,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC;QAAE,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;IAE/D,MAAM,mBAAmB,GAAG,4BAA4B,CAAC,MAAM,CAAC,CAAC;IAEjE,IAAI,mBAAmB,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACrC,OAAO,mBAAmB,CAAC,CAAC,CAAC,CAAC;IAChC,CAAC;IAED,IAAI,SAAS,GAAG,mBAAmB,CAAC,CAAC,CAAC,CAAC;IACvC,IAAI,cAAc,GAAG,SAAS,CAAC,MAAM,CAAC;IAEtC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,mBAAmB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QACpD,MAAM,YAAY,GAAG,mBAAmB,CAAC,CAAC,CAAC,CAAC;QAC5C,IAAI,YAAY,CAAC,MAAM,GAAG,cAAc,EAAE,CAAC;YACzC,SAAS,GAAG,YAAY,CAAC;YACzB,cAAc,GAAG,YAAY,CAAC,MAAM,CAAC;QACvC,CAAC;IACH,CAAC;IAED,OAAO,SAAS,CAAC;AACnB,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,WAAW,CAAC,MAAe;IACzC,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,GAAG,KAAK,IAAI,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC;AACzD,CAAC;AAED;;;;;;;;;;;;;;;GAeG;AACH,MAAM,CAAC,KAAK,UAAU,YAAY,CAChC,OAAe,EACf,QAAkB;IAElB,MAAM,MAAM,GAAG,MAAM,OAAO,CAAC,GAAG,CAC9B,QAAQ,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE,EAAE,EAAE,CAAC,MAAM,QAAQ,CAAC,EAAE,CAAC,CAAC,CAC/C,CAAC;IACF,MAAM,SAAS,GAAG,MAAM,kBAAkB,CAAC,MAAM,CAAC,CAAC;IACnD,MAAM,MAAM,GAAc,SAAS,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAChD,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;QAChB,YAAY,EAAE,CAAC,CAAC,YAAY;QAC5B,OAAO,EAAE,CAAC,CAAC,OAAO;QAClB,GAAG,EAAE,CAAC,CAAC,GAAG;QACV,MAAM,EAAE,KAAK;KACd,CAAC,CAAC,CACJ,CAAC;IACF,OAAO;QACL,OAAO;QACP,QAAQ;QACR,MAAM;KACK,CAAC;AAChB,CAAC;AAED,MAAM,UAAU,kBAAkB,CAAC,GAAW;IAC5C,MAAM,KAAK,GAAG,uCAAuC,CAAC;IACtD,MAAM,KAAK,GAAkB,EAAE,CAAC;IAChC,IAAI,KAAK,CAAC;IACV,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;QAC1C,KAAK,CAAC,IAAI,CAAC;YACT,WAAW,EAAE,KAAK,CAAC,CAAC,CAAC;YACrB,QAAQ,EAAE,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE;SACzB,CAAC,CAAC;IACL,CAAC;IACD,OAAO,KAAK,CAAC;AACf,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport { tokenize } from './tokenize.js';\nimport { augmentTokenGroups } from './augment.js';\n\n/**\n * A Token represents a parsed Japanese morpheme with optional marking state.\n */\nexport interface Token {\n  marked: boolean | undefined;\n  surface_form: string;\n  reading?: string;\n  pos?: string;\n}\n\n/**\n * A Question contains the English prompt with furigana annotations and\n * multiple acceptable Japanese answers.\n */\nexport interface Question {\n  english: string;\n  japanese: string[];\n  parsed: Token[][];\n}\n\n/**\n * ParsedEnglishPart represents a word in the English prompt, optionally\n * with furigana (reading) attached.\n */\nexport interface ParsedEnglishPart {\n  englishWord: string;\n  furigana: string;\n}\n\nexport type ParsedEnglish = ParsedEnglishPart[];\n\n/**\n * Recursive helper to find matching tokens.\n * @returns an array of token‐indices if `str` can be covered by a subsequence\n *          of `tokens[i].reading`, or `null` otherwise.\n */\nexport function findMatch(\n  tokens: Token[],\n  str: string,\n  startIdx: number,\n  pos: number\n): number[] | null {\n  if (pos === str.length) return [];\n  for (let i = startIdx; i < tokens.length; i++) {\n    const r = tokens[i].reading!;\n    if (str.startsWith(r, pos)) {\n      const rest = findMatch(tokens, str, i + 1, pos + r.length);\n      if (rest) return [i, ...rest];\n    }\n  }\n  return null;\n}\n\n/** Flat‐array overload */\nexport function markTokens(\n  tokens: Token[],\n  str: string\n): { matched: number[] | null };\n\n/** Nested‐array overload */\nexport function markTokens(\n  tokens: Token[][],\n  str: string\n): { matched: number[] | null }[];\n\n/**\n * If given a flat Token[], tries to match & flip exactly as before.\n * If given Token[][], first picks only those sub‐arrays with the\n * **highest current count** of `marked===true`, and runs the flat logic\n * on them; all others return `{ matched: null }`.\n */\nexport function markTokens(\n  tokens: Token[] | Token[][],\n  str: string\n): { matched: number[] | null } | { matched: number[] | null }[] {\n  // ——— Nested case ———\n  if (tokens.length > 0 && Array.isArray(tokens[0])) {\n    const groups = tokens as Token[][];\n    const candidateGroups = getGroupsWithMaxMarkedTokens(groups);\n\n    return groups.map((g) => {\n      if (candidateGroups.includes(g)) {\n        return markTokens(g, str) as { matched: number[] | null };\n      } else {\n        return { matched: null };\n      }\n    });\n  }\n\n  // ——— Flat case ———\n  const flat = tokens as Token[];\n  const matchIndices = findMatch(flat, str, 0, 0);\n  if (!matchIndices) {\n    return { matched: null };\n  }\n\n  const newlyMarked: number[] = [];\n  for (const idx of matchIndices) {\n    if (!flat[idx].marked) {\n      flat[idx].marked = true;\n      newlyMarked.push(idx);\n    }\n  }\n  return { matched: newlyMarked };\n}\n\n/**\n * Filters an array of token groups, returning only those with the maximum\n * number of marked tokens.\n */\nexport function getGroupsWithMaxMarkedTokens(groups: Token[][]): Token[][] {\n  if (groups.length === 0) {\n    return [];\n  }\n\n  const markedCounts = groups.map((g) =>\n    g.reduce((n, t) => n + (t.marked ? 1 : 0), 0)\n  );\n  const maxMarkedCount = Math.max(...markedCounts);\n\n  return groups.filter((_, i) => markedCounts[i] === maxMarkedCount);\n}\n\n/**\n * Returns true if any token was newly marked.\n */\nexport function anyMarked(result: { matched: number[] | null }[]): boolean {\n  return result.some((r) => r.matched !== null && r.matched.length > 0);\n}\n\n/**\n * Selects the \"best\" token sequence from an array of candidate groups.\n * Criteria:\n *  1. Highest number of tokens with `marked === true`\n *  2. (Tiebreaker) Lowest number of tokens with `marked === false`\n */\nexport function selectBestGroup(groups: Token[][]): Token[] {\n  if (groups.length === 0) throw new Error('No groups provided');\n\n  const groupsWithMaxMarked = getGroupsWithMaxMarkedTokens(groups);\n\n  if (groupsWithMaxMarked.length === 1) {\n    return groupsWithMaxMarked[0];\n  }\n\n  let bestGroup = groupsWithMaxMarked[0];\n  let minTotalTokens = bestGroup.length;\n\n  for (let i = 1; i < groupsWithMaxMarked.length; i++) {\n    const currentGroup = groupsWithMaxMarked[i];\n    if (currentGroup.length < minTotalTokens) {\n      bestGroup = currentGroup;\n      minTotalTokens = currentGroup.length;\n    }\n  }\n\n  return bestGroup;\n}\n\n/**\n * Returns true if every non-punctuation token in the array is marked.\n */\nexport function isCompleted(tokens: Token[]): boolean {\n  return tokens.every((t) => t.pos === '記号' || t.marked);\n}\n\n/**\n * Creates a Question object from an English prompt and Japanese answer(s).\n * English can include furigana annotations in brackets: \"word[ふりがな]\"\n *\n * @param english - English text with optional furigana annotations\n * @param japanese - Array of acceptable Japanese answers\n * @returns A Question object with tokenized and augmented Japanese\n *\n * @example\n * ```ts\n * const q = await makeQuestion('I live[すむ] in Seattle[シアトル].', [\n *   '私 は シアトル に 住んでいます。',\n *   '私 は シアトル に 住んでる。',\n * ]);\n * ```\n */\nexport async function makeQuestion(\n  english: string,\n  japanese: string[]\n): Promise<Question> {\n  const groups = await Promise.all(\n    japanese.map(async (it) => await tokenize(it))\n  );\n  const augmented = await augmentTokenGroups(groups);\n  const parsed: Token[][] = augmented.map((group) =>\n    group.map((t) => ({\n      surface_form: t.surface_form,\n      reading: t.reading,\n      pos: t.pos,\n      marked: false,\n    }))\n  );\n  return {\n    english,\n    japanese,\n    parsed,\n  } as Question;\n}\n\nexport function parseEnglishString(eng: string): ParsedEnglish {\n  const regex = /([a-zA-Z0-9_']+)\\s*(?:\\[([^\\]]+)\\])?/g;\n  const parts: ParsedEnglish = [];\n  let match;\n  while ((match = regex.exec(eng)) !== null) {\n    parts.push({\n      englishWord: match[1],\n      furigana: match[2] || '',\n    });\n  }\n  return parts;\n}\n"]}